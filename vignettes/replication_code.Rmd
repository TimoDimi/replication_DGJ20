---
title: "replication_code"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{replication_code}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(dplyr)
library(tidyr)
library(reliabilitydiag)
library(RColorBrewer)
library(ggplot2)
```

```{r}
rel.diag.classic <- function(
  rlz,
  FC,
  bins=FALSE,
  plot.theme=theme_gray(),
  plot.col="red",
  plot.hist=TRUE,
  plot.lwd=1,
  plot.lty=1,
  plot.pts.size=3,
  point.x="avg",
  bars=FALSE
) {
  df <- data.frame(FC,rlz)

  # The case without bins
  if (class(bins)=="logical" && bins==FALSE){
    df <- df %>% mutate(bin.index = dense_rank(FC))
    df$bin.midpoint <- df$FC
    df.bins <- df %>%
      group_by(bin.index) %>%
      summarise(
        bin.freq=mean(rlz),
        bin.n=length(rlz),
        bin.midpoint=unique(bin.midpoint))

    # Plot the reliability diagram with histogram embedded
    if (length(unique(df$FC)) <= 5){
      # Use 40 equally spaced bins as histogram breaks if <= 5 unique FCs and
      # reldiags without binning
      p.reldiag <- ggplot(
        data=df.bins,
        mapping=aes(x=bin.midpoint, y=bin.freq)
      ) +
        geom_histogram(
          data=df,
          mapping=aes(x=FC, y = ..ncount../5),
          inherit.aes=FALSE,
          color="black",
          fill="white",
          breaks=seq(0,1,length.out=41)) +
        ylab("") +
        xlab("") +
        xlim(0,1) +
        ylim(0,1)
    } else {
      # Use the unique FC values as histogram breaks if > 5 unique FCs and
      # reldiags without binning
      p.reldiag <- ggplot(
        data=df.bins,
        mapping=aes(x=bin.midpoint, y=bin.freq)
      ) +
        geom_histogram(
          data=df,
          mapping=aes(x=FC, y = ..ncount../5),
          inherit.aes=FALSE,
          color="black",
          fill="white",
          breaks=unique(df$FC)) +
        ylab("") +
        xlab("") +
        xlim(0,1) +
        ylim(0,1)
    }

    p.reldiag <- p.reldiag +
      geom_segment(
        aes(x = 0, y = 0, xend = 1, yend = 1),
        size=plot.lwd/3,
        colour="black") +
      theme(legend.position = "none") +
      geom_point(size=plot.pts.size, colour=plot.col) +
      geom_line(size=plot.lwd, colour=plot.col) +
      plot.theme

  } else {
    # The case with bins
    if (class(bins)=="logical" && bins==TRUE){
      bins <- seq(0,1,length.out=11)
      bin.midpoint <- bins[-length(bins)] + diff(bins)/2
    } else if (class(bins)=="numeric" && length(bins)==1){
      bins <- seq(0,1,length.out=bins + 1)
      bin.midpoint <- bins[-length(bins)] + diff(bins)/2
    } else if (class(bins)=="numeric" && length(bins)>=1){
      bin.midpoint <- bins[-length(bins)] + diff(bins)/2
    } else if (class(bins)=="character" && bins=="quantiles"){
      # split the space [0,1] into up to 10 (unique!!!) bins determined by the
      # quantiles of df$FC
      bins <- unique(
        c(0,as.numeric(quantile(df$FC,seq(0.1,0.9,length.out=9))),1)
      )
      bin.midpoint <- bins[-length(bins)] + diff(bins)/2
    }

    df <- data.frame(FC,rlz)
    df$bin.index <- cut(df$FC, breaks=bins, include.lowest=TRUE, labels = FALSE)
    df$bin.midpoint <- bin.midpoint[df$bin.index]

    df.bins <- df %>%
      group_by(bin.index) %>%
      summarise(
        bin.freq=mean(rlz),
        bin.n=length(rlz),
        bin.n.small=(length(rlz)<=5),
        bin.midpoint=unique(bin.midpoint),
        bin.avg.x = mean(FC))

    # plot either bin averages or bin midpoints on the x-axsis
    if (point.x=="avg"){
      p.reldiag <- ggplot() +
        geom_histogram(
          data=df,
          mapping=aes(x=FC, y = ..ndensity../5),
          inherit.aes=FALSE,
          color="black",
          fill="white",
          breaks=bins) +
        ylab("") +
        xlab("") +
        xlim(0,1) +
        ylim(0,1)
    } else{
      p.reldiag <- ggplot() +
        geom_histogram(
          data=df,
          mapping=aes(x=FC, y = ..ndensity../5),
          inherit.aes=FALSE,
          color="black",
          fill="white",
          breaks=bins) +
        ylab("") +
        xlab("") +
        xlim(0,1) +
        ylim(0,1)
    }


    if (bars==TRUE){
      # Ribbon first
      df.ribbon <- merge(
        df,
        df.bins %>% dplyr::select("bin.index","bin.freq"),
        by="bin.index")
      p.reldiag <- p.reldiag +
        geom_ribbon(
          data=df.ribbon,
          aes(x=FC, ymin=FC, ymax=bin.freq),
          fill = "grey70")

      # Plot Bars instead of connecting lines between the points
      df.bins$bin.lower <- bins[-length(bins)]
      df.bins$bin.upper <- bins[-1]
      df.endpoints <- data.frame(
        x=c(bins[-length(bins)],bins[-1]) ,
        y=rep(df.bins$bin.freq,2),
        bin.index=rep(df.bins$bin.index,2))
      p.reldiag <- p.reldiag +
        geom_line(
          data=df.endpoints,
          aes(x=x, y=y, group=bin.index),
          size=1,
          colour=plot.col)
    } else {
      p.reldiag <- p.reldiag +
        geom_line(
          data=df.bins,
          mapping=aes(x=bin.avg.x, y=bin.freq),
          size=plot.lwd,
          colour=plot.col) +
        theme(legend.position = "none") +
        plot.theme

    }

    p.reldiag <- p.reldiag +
      geom_segment(
        aes(x = 0, y = 0, xend = 1, yend = 1),
        size=plot.lwd/3,
        colour="black") +
      theme(legend.position = "none") +
      geom_point(
        data=df.bins,
        mapping=aes(x=bin.avg.x, y=bin.freq),
        size=plot.pts.size,
        colour=plot.col,
        show.legend = F) +
      scale_shape_manual(values=c(19))
  }

  return(list(df=df, df.bins=df.bins, p=p.reldiag))
}

```



```{r}
precip <- precip_Niamey_2016

```

# Plot for Figure 1

```{r}
Fig1 <- tibble(
  enum = letters[1:6],
  forecast = c("ENS", "EPC", "Logistic") %>% rep(each = 2),
  reldiag_type = c("BaC", "CORP") %>% rep(3)
) %>%
  mutate(., 
    plot = purrr::pmap(., function(enum, forecast, reldiag_type) {
      if (reldiag_type == "BaC") {
        rel.diag.classic(rlz=precip$obs, FC=precip[[forecast]], bins=10)$p +
          ggtitle(sprintf("(%s) %s / Binning and Counting", enum, forecast)) +
          xlab("Forecast value") +
          ylab("CEP") +
          theme_bw()
      } else if (reldiag_type == "CORP") {
        set.seed(42)
        r <- reliabilitydiag(precip[[forecast]], y = precip$obs, n.boot = 100)
        autoplot(r) +
          ggtitle(sprintf("(%s) %s / CORP", enum, forecast)) +
          annotate("text", x = .125, y = .94,
                   label = sprintf("MCB = %.3f", summary(r)$miscalibration))
      }})
  )

```

```{r, eval = FALSE}
purrr::pmap(Fig1, function(enum, forecast, reldiag_type, plot) {
  ggsave(
    sprintf("applications/plots/Fig1%s_%s_%s.pdf", enum, forecast, reldiag_type),
    plot,
    width=5, height=5, units="in"
  )
})

```

```{r, fig.height = 5, fig.width = 5}
Fig1$plot

```
    
# Plot for Figure 2

```{r}
Fig2 <- tibble(
  enum = letters[1:4],
  bins = c(9, 10, 11, NA),
  reldiag_type = c("BaC", "CORP") %>% rep.int(c(3, 1))
) %>%
  mutate(., 
    plot = purrr::pmap(., function(enum, bins, reldiag_type) {
      if (reldiag_type == "BaC") {
        rel.diag.classic(rlz=precip$obs, FC=precip[["EMOS"]], bins=bins)$p +
          ggtitle(sprintf("(%s) EMOS / %i Equidistant Bins", enum, bins)) +
          xlab("Forecast value") +
          ylab("CEP") +
          theme_bw()
      } else if (reldiag_type == "CORP") {
        set.seed(42)
        r <- reliabilitydiag(precip[["EMOS"]], y = precip$obs, n.boot = 100)
        autoplot(r) +
          ggtitle(sprintf("(%s) EMOS / CORP", enum)) +
          annotate("text", x = .125, y = .94,
                   label = sprintf("MCB = %.3f", summary(r)$miscalibration))
      }})
  )

```

```{r, eval = FALSE}
purrr::pmap(Fig2, function(enum, bins, reldiag_type, plot) {
  ggsave(
    sprintf("applications/plots/Fig2%s_%s_%s.pdf", enum, bins, reldiag_type),
    plot,
    width=5, height=5, units="in"
  )
})

```

```{r, fig.height = 5, fig.width = 5}
Fig2$plot

```


# Plots for Figure 3

```{r}
Fig3 <- tibble(
  enum = letters[1:4],
  xtype = c("discrete", "continuous") %>% rep(each = 2),
  region.position = c("diagonal", "estimate") %>% rep(2)
) %>%
  mutate(.,
    plot = purrr::pmap(., function(enum, xtype, region.position) {
      set.seed(42)
      n <- 1024
      if (xtype == "discrete") {
        k <- 10
        x <- sample((1:k - 0.5) / k, n, replace=TRUE)
      } else if (xtype == "continuous") {
        x <- runif(n)
      }
      y <- rbinom(n, 1, x^0.5)
      r <- reliabilitydiag(x, y = y, region.position = region.position)
      autoplot(r) +
        ggtitle(sprintf("(%s)", enum)) +
        annotate("text", x = .125, y = .94,
                 label = sprintf("MCB = %.3f", summary(r)$miscalibration))
    })
    
  )

```

```{r, eval = FALSE}
purrr::pmap(Fig3, function(enum, xtype, region.position, plot) {
  ggsave(
    sprintf("simulations/plots/Fig3%s_%s_%s.pdf", enum, xtype, region.position),
    plot,
    width=5, height=5, units="in"
  )
})

```

```{r, fig.height = 5, fig.width = 5}
Fig3$plot

```

# Coverage simulation

```{r eval = FALSE}
library(doParallel)
library(dplyr)
library(tibble)
library(ggplot2)
library(reliabilitydiag)

M.MC <- 1000
n.set <- 2^seq(6,13)
k.set <- c(10, 20 ,50, Inf)
alpha.set <- c(1)

dist.x.set <- c("unif", "rectangular", "beta-unif")
bounds.plot.set <- c("diagonal","estimate")

ratio.beta.unif <- 4
beta.param.2 <- 10

core.max <- 35
cl <- makeCluster(min(parallel::detectCores()-1, M.MC, core.max) )
registerDoParallel(cl)

start.time <- Sys.time()
df.MC <- foreach(
  i_MC = 1:M.MC,
  .combine=rbind,
  .packages=c("RelDiag", "dplyr", "tibble")
)%dopar%{
  set.seed(i_MC) # set seed for reproducibility
  RealDiag.CIfreq.df <- tibble()

  for (n in n.set){
    for (k in k.set){
      for (dist.x in dist.x.set){
        if (k==Inf){
          if (dist.x=="rectangular"){
            x <- 1/3*(sqrt(15*runif(n)+1) - 1)
          } else if (dist.x=="beta-unif") {
            x <- c(
              rbeta(floor(n*(ratio.beta.unif-1)/ratio.beta.unif),1,beta.param.2),
              runif(ceiling(n/ratio.beta.unif)))
          } else {
            x <- runif(n)
          }
        } else {
          if (dist.x=="rectangular"){
            prob.unnormalized <- seq(1,4,length.out=k)
            prob <- prob.unnormalized/sum(prob.unnormalized)
            x <-(sample(1:k, n, replace=TRUE, prob=prob) - 0.5)/k
          } else if (dist.x=="beta-unif") {
            pdf <- (ratio.beta.unif-1)/ratio.beta.unif *
              dbeta( ((1:k)-0.5)/k ,1,beta.param.2) +
              1/ratio.beta.unif * dunif(((1:k)-0.5)/k)
            prob <- pdf/sum(pdf)
            x <- (sample(1:k, n, replace=TRUE, prob=prob) - 0.5)/k
          } else {
            x <- (sample(1:k, n, replace=TRUE) - 0.5)/k
          }
        }

        for (alpha in alpha.set){
          p <- x^alpha
          y <- rbinom(n, 1, p)

          for (bounds.plot in bounds.plot.set){

            rel <- tryCatch(
              reliabilitydiag(
                p, y=y,
                region.level = 0.9, region.position = bounds.plot, n.boot=100),
              error=function(e) NULL
            )

            if (!is.null(rel)){
              df.bounds <- tibble(
                lower = approx(
                  x=c(0,rel$X$regions$x,1),
                  y=c(0,rel$X$regions$lower,1),
                  xout=rel$X$cases$x)$y,
                upper = approx(
                  x=c(0,rel$X$regions$x,1),
                  y=c(0,rel$X$regions$upper,1),
                  xout=rel$X$cases$x)$y,
                x=rel$X$cases$x,
                bin_id=rel$X$cases$bin_id
              ) %>%
                select(x, lower, upper, bin_id) %>%
                merge(rel$X$bins[,c("bin_id","CEP_pav")], by="bin_id") %>%
                as.tibble()

              if (bounds.plot == "diagonal"){
                df.bounds <- df.bounds %>%
                  mutate(RelDiag_in_Bounds = (CEP_pav >= lower & CEP_pav <= upper))
              } else {
                df.bounds <- df.bounds %>%
                  mutate(RelDiag_in_Bounds = (x >= lower & x <= upper))
              }

              if (k == Inf){
                df.bounds <- df.bounds %>%
                  mutate(x.region=findInterval(x, seq(0,1,by=0.05))) %>%
                  group_by(x.region) %>%
                  summarize(
                    RelDiag_in_Bounds=mean(RelDiag_in_Bounds),
                    .groups="drop") %>%
                  mutate(x.region=(x.region-0.5)/20)
                df.append <- df.bounds %>%
                  add_column(
                    n=n,
                    k=k,
                    alpha=alpha,
                    dist.x=dist.x,
                    bounds.plot=bounds.plot,
                    FC.dist.plot=rel$X$xinfo$type,
                    Bounds.Method=rel$X$regions$method[[1]],
                    i_MC=i_MC)
              } else {
                df.append <- df.bounds %>%
                  group_by(x) %>%
                  summarize(
                    RelDiag_in_Bounds=mean(RelDiag_in_Bounds),
                    .groups="drop") %>%
                  rename(x.region=x) %>%
                  add_column(
                    n=n,
                    k=k,
                    alpha=alpha,
                    dist.x=dist.x,
                    bounds.plot=bounds.plot,
                    FC.dist.plot=rel$X$xinfo$type,
                    Bounds.Method=rel$X$regions$method[[1]],
                    i_MC=i_MC)
              }

              # Add multiple (identical) rows for multiple values of the FCs
              RealDiag.CIfreq.df <- bind_rows(RealDiag.CIfreq.df, df.append)

            }
          }
        }
      }
    }
  }
  RealDiag.CIfreq.df
}
stopCluster(cl)
end.time <- Sys.time()
(run.time <- end.time-start.time)
head(df.MC)

saveRDS(df.MC, file = "./data/sim_Bounds_Coverage_20200722.rds")

```

# Figure 4: Coverage

```{r}
df.MC <- readRDS(file = "./data/sim_Bounds_Coverage_20200722.rds")

plot.df <- df.MC %>%
  dplyr::filter(alpha==1 & !(x.region %in% c(0,1)))  %>%
  group_by(n, k, alpha, dist.x, bounds.plot, FC.dist.plot, Bounds.Method) %>%
  summarize(Value=mean(RelDiag_in_Bounds), counter=n()) %>%
  dplyr::filter(counter >= 100)

bounds.plot.labs <-  c("Consistency Bands", "Confidence Bands")
names(bounds.plot.labs) <- c("diagonal", "estimate")
dist.x.labs <-  c("Uniform", "Linear", "Beta Mixture")
names(dist.x.labs) <- c("unif", "rectangular", "beta-unif")
plot.df$dist.x.arrange <- factor(
  plot.df$dist.x,
  levels=c("unif", "rectangular", "beta-unif"))

p.individual <- ggplot(plot.df, aes(x=n, y=Value)) +
  theme_bw() +
  facet_grid(
    bounds.plot~dist.x.arrange,
    labeller = labeller(
      bounds.plot=bounds.plot.labs,
      dist.x.arrange=dist.x.labs)) +
  geom_hline(yintercept=0.9) +
  geom_line(aes(colour=factor(k)), size=1) +
  geom_point(aes(colour=factor(k), shape=Bounds.Method), size=4) +
  theme(legend.position="bottom", legend.text=element_text(size=rel(1))) +
  theme(
    strip.text.x = element_text(size = 12),
    strip.text.y = element_text(size = 12)) +
  scale_shape_discrete(
    name = "Uncertainty Quantification via",
    labels = c(
      "continuous asymptotic theory",
      "discrete asymptotic theory",
      "resampling")) +
  scale_color_discrete(name = "Number k of Distinct Forecast Values") +
  scale_x_continuous(trans='log2') +
  ylim(0.8,1) +
  ylab("Empirical Coverage") +
  xlab("Sample Size")

```

```{r eval = FALSE}
ggsave(
  paste0("./plots/sim_CoverageDefault_20200722.pdf"),
  p.individual,
  height=8, width=14,units="in")

```

```{r fig.height = 8, fig.width = 14}
p.individual

```

# Simulations Efficiency

```{r eval = FALSE}
library(doParallel)
library(dplyr)
library(tibble)
library(ggplot2)
library(reliabilitydiag)
library(RColorBrewer)

M <- 1000
n.set <- 2^seq(6,13)
k.set <- c(10, 50, Inf)
alpha.set <- c(1)

dist.x.set <- c("unif", "rectangular", "beta-unif")
ratio.beta.unif <- 4
beta.param.2 <- 10

bins.list <- list(5,10,50,"Q-n(1/6)","Q-n(2/6)","Q-n(3/6)")

core.max <- 35
cl <- makeCluster(min(parallel::detectCores()-1, M, core.max) )
registerDoParallel(cl)
start.time <- Sys.time()
res.df.MC <- foreach(
  i_MC = 1:M,
  .combine=rbind,
  .packages=c("RelDiag", "dplyr", "tibble"),
  .export=c("rel.diag.classic")
)%dopar%{
  set.seed(i_MC) # set seed for reproducibility
  res.df <- tibble()

  for (n in n.set){
    for (k in k.set){
      for (dist.x in dist.x.set){
        if (k==Inf){
          if (dist.x=="rectangular"){
            x <- 1/3*(sqrt(15*runif(n)+1) - 1)
          } else if (dist.x=="beta-unif") {
            x <- c(
              rbeta(floor(n*(ratio.beta.unif-1)/ratio.beta.unif),1,beta.param.2),
              runif(ceiling(n/ratio.beta.unif)))
          } else {
            x <- runif(n)
          }
        } else {
          if (dist.x=="rectangular"){
            prob.unnormalized <- seq(1,4,length.out=k)
            prob <- prob.unnormalized/sum(prob.unnormalized)
            x <-(sample(1:k, n, replace=TRUE, prob=prob) - 0.5)/k
          } else if (dist.x=="beta-unif") {
            pdf <- (ratio.beta.unif-1)/ratio.beta.unif *
              dbeta( ((1:k)-0.5)/k ,1,beta.param.2) +
              1/ratio.beta.unif * dunif(((1:k)-0.5)/k)
            prob <- pdf/sum(pdf)
            x <- (sample(1:k, n, replace=TRUE, prob=prob) - 0.5)/k
          } else {
            x <- (sample(1:k, n, replace=TRUE) - 0.5)/k
          }
        }

        for (alpha in alpha.set){
          p <- x^alpha
          y <- rbinom(n, 1, p)

          # PAV Reliability Diagram
          rel <- reliabilitydiag(p, y=y, region.level = NA)
          CEP.df <- with(rel$X, merge(cases, bins, by.x="bin_id"))
          CEP.df <- CEP.df %>% mutate(CEPtrue = x^alpha)
          MSE <- with(CEP.df, mean((CEP_pav-CEPtrue)^2))

          if (!is.null(MSE)){
            res.df <- rbind(
              res.df,
              tibble(
                Measure="MSE",
                RelDiag.Type="PAV",
                MC.rep=i_MC,
                n=n,
                m.bins="PAV",
                alpha=alpha,
                dist.x=dist.x,
                k=k,
                Value=MSE))
          }

          # "Classic" Reliability Diagrams
          for (bins.index in 1:length(bins.list)){

            if (class(bins.list[[bins.index]]) == "numeric"){
              m.bins <- bins.list[[bins.index]]
            } else if (bins.list[[bins.index]] == "n(1/6)") {
              m.bins <- floor(n^(1/6))
            } else if (bins.list[[bins.index]] == "n(2/6)") {
              m.bins <- floor(n^(2/6))
            } else if (bins.list[[bins.index]] == "n(3/6)") {
              m.bins <- floor(n^(3/6))
            } else if (bins.list[[bins.index]] == "n(4/6)") {
              m.bins <- floor(n^(4/6))
            } else if (bins.list[[bins.index]] == "Q-n(1/6)") {
              bins.amount <- max(3,floor(n^(1/6)))
              m.bins <- unique(
                c(0,quantile(x, (1:(bins.amount-1))/bins.amount),1)
              )
            } else if (bins.list[[bins.index]] == "Q-n(2/6)") {
              bins.amount <- max(3,floor(n^(2/6)))
              m.bins <- unique(
                c(0,quantile(x, (1:(bins.amount-1))/bins.amount),1)
              )
            } else if (bins.list[[bins.index]] == "Q-n(3/6)") {
              bins.amount <- max(3,floor(n^(3/6)))
              m.bins <- unique(
                c(0,quantile(x, (1:(bins.amount-1))/bins.amount),1)
              )
            }

            RelDiag.Bins <- tryCatch(
              rel.diag.classic(y, x, bins=m.bins),
              error=function(e) NULL)
            df <- with(RelDiag.Bins, merge(df, df.bins, by="bin.index")) %>%
              as.tibble() %>%
              arrange(FC)
            CEP.df.classic <- df %>%
              summarize(x = FC, CEPtrue =x^alpha, CEP.est = bin.freq )
            MSE.classic <- with(CEP.df.classic, mean((CEP.est-CEPtrue)^2))

            if (!is.null(RelDiag.Bins)){
              if (class(bins.list[[bins.index]])=="numeric"){
                res.df <- rbind(
                  res.df,
                  data.frame(
                    Measure="MSE",
                    RelDiag.Type="Bins.fixed",
                    MC.rep=i_MC,
                    n=n,
                    m.bins=as.character(bins.list[[bins.index]]),
                    alpha=alpha,
                    dist.x=dist.x,
                    k=k,
                    Value=MSE.classic))
              } else if (class(bins.list[[bins.index]])=="character" &
                         substring(bins.list[[bins.index]],1,1)=="Q"){
                res.df <- rbind(
                  res.df,
                  data.frame(
                    Measure="MSE",
                    RelDiag.Type="Bins.Q.n",
                    MC.rep=i_MC,
                    n=n,
                    m.bins=substring(bins.list[[bins.index]],3),
                    alpha=alpha,
                    dist.x=dist.x,
                    k=k,
                    Value=MSE.classic))
              } else {
                res.df <- rbind(
                  res.df,
                  data.frame(
                    Measure="MSE",
                    RelDiag.Type="Bins.n",
                    MC.rep=i_MC,
                    n=n,
                    m.bins=as.character(bins.list[[bins.index]]),
                    alpha=alpha,
                    dist.x=dist.x,
                    k=k,
                    Value=MSE.classic))
              }
            }
          }
        }
      }
    }
  }

  res.df
}
stopCluster(cl)
end.time <- Sys.time()
(run.time <- end.time-start.time)

saveRDS(res.df.MC, file = "./data/sim_RelMeasures_Convergence_20200726.rds")

```

# Figure 5: Efficiency

```{r}
res.df.MC <- readRDS(file = "./data/sim_RelMeasures_Convergence_20200726.rds")

res.df <- res.df.MC %>%
  group_by(Measure, RelDiag.Type, n, m.bins, alpha, dist.x, k) %>%
  summarize(Value = mean(Value), count=n())

df.plot <- res.df %>%
  filter(
    RelDiag.Type %in% c("PAV","Bins.fixed","Bins.Q.n") &
      alpha==1  &
      Measure=="MSE" &
      k%in%c(10,50,Inf) &
      m.bins%in%c("PAV",5,10,50,"n(1/6)","n(2/6)","n(3/6)")) %>%
  arrange(
    Measure,
    alpha,
    dist.x,
    k,
    n,
    RelDiag.Type,
    match(RelDiag.Type, c("PAV", "Bins.fixed", "Bins.Q.n")),
    match(m.bins, c("PAV", "5", "10", "50", "n(1/6)", "n(2/6)", "n(3/6)")))

df.plot$m.bins.arrange <- factor(
  df.plot$m.bins,
  levels=c("PAV", "5", "10", "50", "n(1/6)", "n(2/6)", "n(3/6)"))

df.plot$dist.x.arrange <- factor(
  df.plot$dist.x,
  levels=c("unif", "rectangular", "beta-unif"))
dist.x.labs <-  c("Uniform", "Linear", "Beta Mixture")
names(dist.x.labs) <- c("unif", "rectangular", "beta-unif")

k.labs <-  c("Discrete: k = 10", "Discrete: k = 50", "Continuous")
names(k.labs) <- c("10","50","Inf")

options(scipen=100)

p.eff <- ggplot(df.plot, aes(x=n, y=Value)) +
  theme_bw() +
  geom_line(aes(linetype=RelDiag.Type, color=m.bins.arrange), size=1) +
  facet_grid(
    k~dist.x.arrange,
    labeller = labeller(dist.x.arrange=dist.x.labs, k=k.labs), scales="free") +
  theme(
    strip.text.x = element_text(size = 12),
    strip.text.y = element_text(size = 12)) +
  scale_x_continuous(trans='log2') +
  scale_y_log10() +
  scale_color_manual(
    values=c(
      "green3",
      brewer.pal(n = 4, name = 'Reds')[2:4],
      brewer.pal(n = 5, name = 'Blues')[3:5]),
    name = " ",
    labels=c(
      "CORP",
      "5","10","50",
      expression(n^{1/6}), expression(n^{1/3}), expression(n^{1/2}))) +
  scale_linetype_manual(
    values=c("PAV"="solid", "Bins.fixed"="longdash","Bins.Q.n"="dotted"),
    name = "Binning Method",
    labels = c("CORP","fixed","n-dependent")) +
  theme(legend.position="bottom", legend.box = "horizontal") +
  guides(color=guide_legend(nrow=1), linetype=FALSE) +
  theme(legend.position="bottom") +
  ylab("MSE") +
  xlab("Sample Size n")

```

```{r eval = FALSE}
ggsave("./plots/Efficiency_Wide.pdf", p.eff, height=8, width=14, units="in")

```

```{r fig.height = 8, fig.width = 14}
p.eff

```

